---
title: "K = 4 multinomial predictions"
author: "Camilo Posso"
date: "06/02/2022"
output: 
  html_document:
    code_folding: hide
    toc: true
editor_options: 
  chunk_output_type: inline
---

## Goal

Predict subtypes on the 51 held out samples, as well as entirely new datasets. CHeck
survival, mutation, etc.


```{r include=FALSE}
library(dplyr)
library(ggplot2)
library(glmnet)
# library(gridExtra)
# library(grid)
library(ggpubr)
library(ggalluvial)
library(stringr)
source("../NMF_helper.R")
source("../cluster_model_helper.R")

names(subtype_colors) <- as.character(1:8)
subtype_colors <- subtype_colors[1:4]

```


Loading model results.


Setting up models

```{r}

## Global model
data_mat <- global_mat_train

cluster_lab <- enet_meta %>%
  mutate(cluster_lab = paste("Cluster", k.4)) %>%
  pull(cluster_lab) %>%
  as.factor()
names(cluster_lab) <- enet_meta$Barcode.ID
cluster_lab <- cluster_lab[colnames(data_mat)]

model_global <- glmnet(x = t(data_mat),
                       y = cluster_lab,
                       family = 'multinomial',
                       alpha = 0.7,
                       lambda = 0.0114996)


## Global + Phospho model
data_mat <- combined_v2_mat_train

cluster_lab <- enet_meta %>%
  mutate(cluster_lab = paste("Cluster", k.4)) %>%
  pull(cluster_lab) %>%
  as.factor()
names(cluster_lab) <- enet_meta$Barcode.ID
cluster_lab <- cluster_lab[colnames(data_mat)]

model_global_phospho <- glmnet(x = t(data_mat),
                               y = cluster_lab,
                               family = 'multinomial',
                               alpha = 0.9,
                               lambda = 0.007655539)


## Global + Phospho imputed model
data_mat <- combined_mat_train

cluster_lab <- enet_meta %>%
  mutate(cluster_lab = paste("Cluster", k.4)) %>%
  pull(cluster_lab) %>%
  as.factor()
names(cluster_lab) <- enet_meta$Barcode.ID
cluster_lab <- cluster_lab[colnames(data_mat)]

model_global_phospho_imputed <- glmnet(x = t(data_mat),
                                       y = cluster_lab,
                                       family = 'multinomial',
                                       alpha = 0.9,
                                       lambda = 0.003933862)


```


# Predicting on new data.


```{r}
subtype_prediction_new_data <- function(new_data_long, model,
                                        feature_str = "feature", sample_str = "sample", 
                                        value_str = "LogRatio", zero_2_NA = FALSE,
                                        complete_only = FALSE){
  
  model_features <- rownames(model$beta$`Cluster 1`)
  sig_features <- sapply(model$beta, function(coefs){
    rownames(coefs)[which(coefs != 0)]
  }) %>% unlist() %>% unname() %>% unique()

  
  if (zero_2_NA){
    n_zeros <- sum(new_data_long[[value_str]] == 0)
    cat(paste0("Replacing exact zero with NA in a total of ", n_zeros, " entries.\n"))
    new_data_long <- new_data_long %>%
      filter(!!as.symbol(value_str) != 0)
  }
  
  mat_new <- new_data_long %>%
    select(feature = sym(feature_str), sample = sym(sample_str), value = sym(value_str)) %>%
    pivot_wider(names_from = "sample", values_from = "value", values_fn = mean) %>%
    column_to_rownames("feature") %>% as.matrix()
  
  if (complete_only){
    ## Since we use na.rm = F, the effect is that any rows with NA will be
    ## imputed with zero. The imputation is still necessary to use the model, but the
    ## difference is the features with incomplete data are thrown out.
    incomplete_features <- rownames(mat_new)[!complete.cases(mat_new)]
    mat_new <- sweep(mat_new, 1, apply(mat_new, 1, mean, na.rm = F), FUN = '-')
    mat_new <- sweep(mat_new, 1, apply(mat_new, 1, sd, na.rm = F), FUN = '/')
    mat_new[is.na(mat_new)] <- 0  
  } else {
    mat_new <- sweep(mat_new, 1, apply(mat_new, 1, mean, na.rm = T), FUN = '-')
    mat_new <- sweep(mat_new, 1, apply(mat_new, 1, sd, na.rm = T), FUN = '/')
    ## Impute with the mean.
    mat_new[is.na(mat_new)] <- 0
  }
  
  
  ## Including the necessary features for the model only. 
  #  Missing features are filled with 0.
  mat_new <- mat_new[rownames(mat_new) %in% model_features, ]
  dummy_rows <- setdiff(model_features, rownames(mat_new))
  dummy_mat <- matrix(0, ncol = ncol(mat_new), nrow = length(dummy_rows))
  rownames(dummy_mat) <- dummy_rows
  colnames(dummy_mat) <- colnames(mat_new)
  mat_new <- rbind(mat_new, dummy_mat)
  mat_new <- mat_new[model_features, ]
  
  n_imputed <- length(intersect(sig_features, dummy_rows))
  if (complete_only){
    n_imputed <- n_imputed + length(intersect(sig_features, 
                                              incomplete_features))
  }
  cat(paste0("Adding ", n_imputed, " constant features needed for subtype prediction.\n"))
  
  
  cluster_predictions <- predict(
    model,
    newx = t(mat_new), 
    type = "response"
    )[, , 1] %>% as.data.frame()
  
  colnames(cluster_predictions) <- paste("New", colnames(cluster_predictions))
  cluster_predictions$max_new <- apply(cluster_predictions, 1, max) %>% unname()
  cluster_predictions$pred_cluster <- 
    predict(model, newx = t(mat_new), type = "class") %>%
    as.character()
  
  cluster_predictions$sample <- colnames(mat_new)

  return(list("combined_mat" = mat_new, "cluster_predictions"=cluster_predictions))
}


```


## Making predictions








```{r WG data}


prot_id <- "syn51082494"
phospho_id <- "syn51425620"

prot_data <- read.table(syn$get(prot_id)$path, sep = "\t", header=TRUE) %>%
  subset(select = -c(Index)) %>%
  # requires a flat dataframe...
  melt() %>%
  mutate( feature = Gene_name, sample = variable) %>%
  select(-Gene_name, -variable)  %>%
  mutate(data_type = "Global") 


phos_data <- read.table(syn$get(phospho_id)$path, sep = "\t", header=TRUE)
phos_data$Gene_site <- str_replace(phos_data$Gene_site, "_", "-")

phos_data <- phos_data%>%
  subset(select = -c(SequenceWindow)) %>%
  melt() %>%
  mutate( feature = Gene_site, sample = variable) %>%
  select(-Gene_site, -variable)  %>%
  mutate(data_type = "Phospho") 


all_protein_data <- prot_data %>% rbind(phos_data) %>% distinct()
print( length(unique(phos_data$sample)))
print( length(unique(prot_data$sample)))
print( length(unique(all_protein_data$sample)))
all_protein_data <- read.csv2(
  "../global_phosph_flat_data.csv", 
  sep =",",  
  na.strings=c("NA","NaN", "")
  )

all_protein_data <- all_protein_data %>%
  mutate( feature = label) 
global_predictions <- subtype_prediction_new_data(
  new_data_long = prot_data, 
  model = model_global,
  sample_str = "sample", value_str = "value", 
  zero_2_NA = TRUE,
  complete_only = FALSE
  )


write.table(global_predictions$cluster_predictions, "global_subtype_predictions.txt", 
            sep = "\t", quote = F, row.names = F)


both_results <- subtype_prediction_new_data(
  new_data_long = all_protein_data, 
  model = model_global_phospho,
  sample_str = "sample", value_str = "value", 
  zero_2_NA = TRUE, complete_only = FALSE
  )
write.table(both_results$cluster_predictions, "global_phospho_subtype_predictions.txt", 
            sep = "\t", quote = F, row.names = F)

both_results_na <- subtype_prediction_new_data(
  new_data_long = all_protein_data, 
  model = model_global_phospho,
  sample_str = "sample", value_str = "value", 
  plot_title = "cptac4", 
  zero_2_NA = TRUE, complete_only = TRUE
  )

write.table(both_results_na$cluster_predictions, "global_phospho_subtype_predictions_2.txt", 
            sep = "\t", quote = F, row.names = F)


```






